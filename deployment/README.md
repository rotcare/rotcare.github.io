# 部署

目标是实现更小粒度的部署。通过控制一次变更产生的影响范围，实现有信心地快速验证。否则就会导致上线战战兢兢，无法做大的修改，也无法快速获得真实的反馈。阻碍这个目标的原因包括：

* 数据库只能有一个版本，无法多个版本的表结构并存。我们可以用只加字段的方式获得前向的兼容，但是仍然只有一个版本。
* iOS 的 App，微信小程序的 Appid，都需要审核才能发布。使得我们更倾向于多个组织，或者多个客户，共享同一个 App，从而使得他们必须同时使用一个版本。
* 前端调用后端，后端服务之间的RPC调用，都有兼容性问题。当RPC接口发生了不兼容的修改，就需要按顺序同时变更多个服务。
* 数据统计是一级级的聚合表。上游的数据结构变更就会影响到下游的统计逻辑。

我们一个个问题来看。

## 多租户

数据库只能有一个版本的问题，其解决办法就是用多个数据库。这个做法有很多名字

* 在 SaaS 领域，称之为多租户，Multi Tenancy
* 在游戏领域，称之为游戏的区服
* 在腾讯的技术体系里，称之为 SET 化
* 在阿里的技术体系里，称之为单元化

其核心就是要把数据硬切割成多个数据库。其诉求出发点可能是不同的

* 把一个数据库部署在北京，另外一个数据库部署在广州，之间可以有很高的网络延迟。让数据离用户更近
* 把数据切成多个数据库，一次表结构变更只影响其中一个数据库
* 避免不同的租户之间产生数据权限的意外泄露

其实现最简单的可以是把原来在一个 Mysql 表中用字段 tenantId 区分出来的数据，改成每个 tenant 建立一个独立的 Mysql Database。连接到数据库的时候用 USE database_name 指定要连接的数据库。

## 多服务名

后端服务与表结构是强耦合的。当每个租户有独立的数据库，那么表结构在变更过程中，就会不同的租户，其表结构不一致。假设我们有如下的访问关系

```
main-svc => mysql
```

切分了数据库之后，就变成了

```
tenant1.main-svc => tenant1.mysql
tenant2.main-svc => tenant2.mysql
...
```

从服务名的角度来说，mysql 就变成了多个服务名，main-svc 是后端代码（比如 node.js 代码），也变成了多个服务名。这样当前端去访问后端服务的时候，可以连到自己的服务名的后端服务上。当tenant1.mysql 升级了表结构之后，我们可以仅升级 tenant1.main-svc。其他的 mysql，其他的 main-svc 都不会受到影响。

这里只是从服务名有多个，并不意味着实际有多个 kubernetes 的 pod 在跑。如果是免费的 SaaS 服务，给每个租户启动一个独立的 pod 是成本太高的事情。多个服务名可以实际解析到同一个服务进程，从而实现资源的复用。这个和 Web Hosting 的虚拟主机一样，同一个 Nginx 进程可以提供多个 http/https 域名的网站。如果后端服务是跑在 FaaS 上的，这个就更简单了，用 function alias 就可以。

后端服务之间的 RPC 也和前端调用后端一样，需要通过 tenant1.main-svc 这样的服务名来进行。调用使用访问的是 tenant1.main-svc 的最新版本，也就是一个服务名仅仅会对应一个版本。如果没有给每个租户分配独立的服务名，那么跨租户访问的时候 other-svc => main-svc 就要知道访问的是 main-svc 的哪个版本，就有一个版本号的协商问题。main-svc 要问一下对方需要哪个版本的，然后看看自己对应版本的服务进程还在不在。分出了多个服务名之后就没有这些版本协商的麻烦事，总是访问最新版本就好了。这也意味着 tenant1.main-svc 如果切到了新版本，所有依赖这个服务的其他服务也要能兼容，或者也要同步更新到新的版本。

## 向前兼容

无论如何切租户，升级总是要时间的。完全停止服务，统一升级是可选的一个策略。向前兼容是另外一个策略。向前兼容是为 7*24 不间断服务需要额外支出的成本。

tenant1.mysql 从 v15 升级到 v16，需要原来访问 v15 的 tenant1.main-svc 可以在切换到 v16 之后仍然正常工作。对于数据库服务而言，这意味只能加非必填字段，只有这样才是向前兼容的。如果要修改字段类型，删字段，都需要先把调用方先升级上来，然后再做一次版本升级，把没有人使用的字段给去掉。

向前兼容也可以是在 tenant1.main-svc 这个层面来做。比如 other-svc 之前访问了 tenant1.main-svc / tenant1.mysql 的 v15。这个时候升级 tenant1.main-svc / tenant1.mysql 都升级了 v16。如果需要 other-svc 不升级，就需要 tenant1.main-svc 能够兼容之前的 RPC 接口。

## 多版本打包发版

iOS / Android / 微信小程序，这些带审核的客户端渠道有时无法给每个 tenant 申请一个独立的 app，比如：

* 申请独立 app 需要资质审核，需要费用。不是每个 tenant 都有资质，或者都希望出这个费用
* 独立的 app 流量需要独立获取。大家希望抱团取暖，都用同一个 app，然后 app 内再切割出自己的流量

这个时候就会出现共享版的 app，多个租户共享了同一个 iOS / Android / 微信小程序意义下的版本。这就导致了一份前端代码，可能要访问很多个版本的后端服务。当后端服务版本不一致的时候，前端代码就会出错。

解决办法就是多版本要打包到一起，做为一个版本进行送审和发版。然后在运行时，根据实际访问的租户不同，切换这个租户的客户端代码的实际运行版本。这种运行流量切换的做法，传统上称之为 feature toggle，a/b test。实际上已经从原本的实验功能，演化为一种版本发布策略了。一个功能做好了先不开流量，等实际成熟，才通过配置下发的方式开流量是一种规避审核速度限制，控制风险的办法。

## 版本协商和停服公告

客户端可能有以下两种情况

* 同时有 iOS / Android / 微信小程序 / 字节小程序 ... 等不同的渠道
* Android 应用经常不升级，很多用户可能停留在一个很早期的版本

这就会导致后端的接口需要向前兼容非常长的时间。这个时候就需要客户端在 RPC 请求的时候把自己的版本号带上来。根据这个版本号，可能有三种响应：

* 根据客户端的版本号，前置一个 RPC 请求改写的程序，把接口适配到最新的版本上来
* 告诉过低的版本号的客户端升级，此版本已经停止服务
* 告诉客户端服务端在停服维护中

注意前端访问后端的时候，其服务名应该是 tenant1.main-svc 而不是 v15.main-svc。一个服务名始终只应该有一个版本在提供服务。版本号不是服务名的一部分，仅仅是做为业务参数传递。为什么不让 v15 和 v16 两个不同版本的后端服务一起长期运行，让客户端选择自己要连什么版本就好了？因为这样会导致同一份数据，同时需要被很多个版本的代码进行读写。长期多个版本并存非常容易出现意想不到的逻辑漏洞，维护成本非常高昂。短期内新旧两个版本并存，向前兼容，那是为了 7*24 服务付出的额外代价。而且那个也仅仅是发布周期内的并存，并不是 Android 应用长期不升级，这样的时间尺度上的并存。

如果可能，尽量选择停服维护。让依赖链条上的所有参与方都尽快升级到同一个版本。不为不必要的向前兼容支付代价。

## 总结

* 数据切成多租户的
* 后端服务按租户切成多个服务名
* 客户端使用多版本打包发版，用配置下发的方式运行时切换实际版本
* 一次升级一个租户的所有版本，从数据库到后端到前端。升级过程中尽量选择停服维护。
* 只有当 7*24 有明确收益的时候，才选择短暂向前兼容
* 永远不要一直向前兼容，到了一定程度就要放弃

