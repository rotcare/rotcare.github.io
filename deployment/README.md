# 部署

目标是实现更小粒度的部署。通过控制一次变更产生的影响范围，实现有信心地快速验证。否则就会导致上线战战兢兢，无法做大的修改，也无法快速获得真实的反馈。阻碍这个目标的原因包括：

* 数据库只能有一个版本，无法多个版本的表结构并存。我们可以用只加字段的方式获得前向的兼容，但是仍然只有一个版本。
* iOS 的 App，微信小程序的 Appid，都需要审核才能发布。使得我们更倾向于多个组织，或者多个客户，共享同一个 App，从而使得他们必须同时使用一个版本。
* 前端调用后端，后端服务之间的RPC调用，都有兼容性问题。当RPC接口发生了不兼容的修改，就需要按顺序同时变更多个服务。
* 数据统计是一级级的聚合表。上游的数据结构变更就会影响到下游的统计逻辑。

我们一个个问题来看。

## 多租户

数据库只能有一个版本的问题，其解决办法就是用多个数据库。这个做法有很多名字

* 在 SaaS 领域，称之为多租户，Multi Tenancy
* 在游戏领域，称之为游戏的区服
* 在腾讯的技术体系里，称之为 SET 化
* 在阿里的技术体系里，称之为单元化

其核心就是要把数据硬切割成多个数据库。其诉求出发点可能是不同的

* 把一个数据库部署在北京，另外一个数据库部署在广州，之间可以有很高的网络延迟。让数据离用户更近
* 支持全链路压测，避免压测产生的脏数据影响生产环境
* 控制变更的影响范围，一次表结构变更只影响其中一个数据库
* 避免不同的租户之间产生数据权限的意外泄露

其实现最简单的可以是把原来在一个 Mysql 表中用字段 tenantId 区分出来的数据，改成每个 tenant 建立一个独立的 Mysql Database。连接到数据库的时候用 USE database_name 指定要连接的数据库。

多租户应该是内置的初始设计，因为事后添加往往代价会更高。

## 多版本

因为升级需要一段时间的关系，多个租户之间的数据库表结构可能是不同版本的。那么就不能一套前端代码，访问一套后端代码，再访问各个租户自己的数据库，因为这会有代码和表结构不兼容的问题。解决办法就是在服务名上加上版本。之前是：

```
main-ui => main-svc => mysql
```

加上了版本之后就是

```
v1.0.2-main-ui => v1.0.2-main-svc => mysql
```

每个租户的数据库升级之前要把前端域名先停掉（挂维护公告等），然后升级数据库表结构到 v1.0.3，升级完之后再把域名指向兼容的 v1.0.3-main-ui 版本。这样在升级过程中，其他租户的域名是不受影响的，数据库也是不受影响的。多个租户如果版本相同，其后端服务等资源也是可以共享的。

## 向前兼容

通过切租户，我们可以避免把所有的租户都关闭，统一维护。但是无论如何切租户，升级总是要时间的。向前兼容是另外一个策略。向前兼容是为 7*24 不间断服务需要额外支出的成本。

一般的实现方式是数据库升级保持兼容，也就是仅仅加字段，而不删字段。先第一步把字段给加好。

然后把 v1.0.3-main-ui 和 v1.0.3-main-svc 这些前后端服务给部署了。

第三步把升级租户的域名从 v1.0.2-main-ui 指向 v1.0.3-main-ui，从而实现不停服的发布。当所有的流量都在读写新数据库字段之后，再做一次发布把旧字段给删掉。

## Deployment v.s. Release

iOS / Android / 微信小程序，这些带审核的客户端渠道有时无法给每个 tenant 申请一个独立的 app，比如：

* 申请独立 app 需要资质审核，需要费用。不是每个 tenant 都有资质，或者都希望出这个费用
* 独立的 app 流量需要独立获取。大家希望抱团取暖，都用同一个 app，然后 app 内再切割出自己的流量

这个时候就会出现共享版的 app，多个租户共享了同一个 iOS / Android / 微信小程序意义下的版本。这就导致了一份前端代码，可能要访问很多个版本的后端服务。当后端服务版本不一致的时候，前端代码就会出错。这意味着不仅仅数据库不能改表结构，连后端服务的 RPC 结构都不做不兼容的修改。这样的向前兼容显然是很大的负担，会造成很糟糕的开发者体验。

解决办法就是多版本要打包到一起，做为一个版本进行送审和发版（所谓 Deployment）。然后在运行时，根据实际访问的租户不同，切换这个租户的客户端代码的实际运行版本（所谓 Release）。这种运行流量切换的做法，传统上称之为 feature toggle，a/b test。实际上已经从原本的实验功能，演化为一种版本发布策略了。一个功能做好了先不开流量，等实际成熟，才通过配置下发的方式开流量是一种规避审核速度限制，控制风险的办法。

这样即便多个租户使用同一个 iOS / Android / 微信小程序 App，我们仍然可以运行该租户指定版本的 main-ui，就像用域名发布 H5 页面一样灵活。H5 页面相当于同时完成了 Deployment 和 Release，是最灵活的发布方式。用户只要在浏览器上 F5 刷新，就完成了重新 Deployment。

## 版本协商和停服公告

客户端可能有以下两种情况

* 同时有 iOS / Android / 微信小程序 / 字节小程序 ... 等不同的渠道，不同渠道不会同时更新
* Android 应用经常不升级，很多用户可能停留在一个很早期的版本

所以客户端是很可能一直运行着非常旧版本的代码的。前面说了，v1.0.2-main-ui 会访问自己兼容的 v1.0.2-main-svc 的后端服务，这样也就会导致旧版本的后端服务一直有访问流量。这显然会有问题

* 数据库如果需要大改表结构，我们可能就是希望停服维护，而不是向前兼容的 Zero Downtime Release 方式。
* 升级之后的数据库表结构不兼容了，旧版本必须强制升级

这里就需要引入一个版本协商的过程。客户端必须经过登陆才能访问服务端，登陆的时候，客户端告诉服务端自己是什么版本，服务端要告诉客户端目前是否维护中，以及应该使用哪个版本来访问。如果客户端过旧了，则要弹框提示用户升级。如果客户端打包了多个版本的代码（Deployment 和 Release 分离的情况），服务端返回的版本号恰好客户端能够提供的，客户端就切换到对应版本的代码执行。

这个版本协商基于数据库中存放的数据来决定。一般都会有一张 migration 表来记录当前数据库是什么版本的，利用类似的机制，我们就可以用 service_version 表来记录不同版本的客户端，应该给予什么样的应答。数据库升级的时候，要同步维护 service_version 表中的数据。如果表结构是兼容的，可能有多个版本的前后端都可以并存。当数据库 Migrate 升级完了，对应的客户端也会被迫升上来，确保版本之间的兼容性。

如果需要立即停服，还需要能够把已有的客户端踢下线的功能。如果每个业务 RPC 请求都会访问 redis 校验 access_token（虽然这有点浪费，但是实践中还是 ok 的），可以把指定租户的 redis 清空，达到迫使客户端重新登陆，重新版本协商的目的。

## 租户数据库的创建和版本升级

多租户量变引起质变的一个问题是租户数量的变多，使得数据库表结构的创建无法是运维手工做的。必须使用某种自动化程序来 provision （创建）新租户。

* 租户的 database 谁来创建
* 新租户的表都怎么建
* 已有租户的表和数据怎么migrate？

假设我们有 main-svc，也有 host-svc 等其他服务。不同服务的租户创建时机，租户数量都不同。一般，总是有一些平台服务来负责创建面向商户，面向用户的租户。比如 host-svc 仅有一个租户，用来提供平台功能，而 main-svc 的租户都是由 host-svc 来创建。这样，我们可以开发者/运维手工部署发布 host-svc 的租户，然后由 host-svc 来创建 main-svc 的租户。那这样， host-svc 的租户数据库可以是运维手工创建的。而 main-svc 的租户数据库，则是由 host-svc 来创建的。

第二个问题是表是谁来创建的。表和后端代码有版本相容性，应该把建表代码写在后端代码里。新建租户的初始化，和已有租户的升级，通过调用租户后端代码的接口来实现，比如 migrate 函数。而 migrate 函数如何知道谁是合法的调用者呢？因为 main-svc 的租户数据库是由 host-svc 创建的，host-svc 可以把自己的凭证在创建数据库的时候写入，从而仍然让 main-svc 授信给 host-svc 调用 migrate 函数。

升级的时候，怎么按顺序执行升级迁移脚本呢？理论上来说，我们可以让 v1.0.3-main-svc 拥有 v1.0.2-main-svc 以及之前版本的迁移代码，只要保留着代码不删，一直加就好了。但是这样会导致两个问题，迁移代码会越来越多，同时很难保证v1.0.1-main-svc => v1.0.2-main-svc 的迁移逻辑在后续的版本里会不会给修改了。所以更好的办法是保留着 v1.0.2-main-svc 在那里，当 v1.0.3-main-svc 要迁移的时候，直接调用旧版本服务的 RPC 接口就好了。

接下来的问题是如何修复之前有问题的迁移代码呢？这个可以通过在代码中维护版本列表来实现，比如 `['v1.0.1-main-svc', 'v1.0.2-main-svc']`，如果 v1.0.2-main-svc 有问题，那么我们可以在后续的版本中，把 v1.0.2-main-svc 的迁移代码重新实现一遍，然后跳掉这个版本。`['v1.0.1-main-svc', 'v1.0.3-main-svc']`

如何保证新建的租户表结构，和迁移上来的表结构是一致的呢?通过反查 information_schema，保证双向一致。

## 总结

* 数据切成多租户的
* 后端服务按租户切成多个服务名
* 客户端使用多版本打包发版，用配置下发的方式运行时切换实际版本
* 一次升级一个租户的所有版本，从数据库到后端到前端。升级过程中尽量选择停服维护。
* 只有当 7*24 有明确收益的时候，才选择短暂向前兼容
* 永远不要一直向前兼容，到了一定程度就要放弃

